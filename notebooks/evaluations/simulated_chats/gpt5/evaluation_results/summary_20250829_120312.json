{
  "timestamp": "20250829_120312",
  "metrics": {
    "agent_selection": {
      "average_score": 4.333333333333333,
      "num_evaluations": 3,
      "num_errors": 0,
      "results": [
        {
          "id": "21f2e08161ef6e94c4b7835c02b8060bf534659c2109be987f2c113a3f397c11",
          "patient_id": "patient_4",
          "result": {
            "score": 5,
            "explanation": "Rating: 5\n\nExplanation:\n- Correct agent selection for each task:\n  - PatientHistory was used to confirm access parameters and later to retrieve critical missing elements influencing prognosis (basis for M1a, CNS imaging status, latest ECOG). This is the appropriate agent for chart retrieval and source-cited details.\n  - PatientStatus was correctly tasked with synthesizing a concise current clinical snapshot to frame prognosis, calling out gaps requiring clarification.\n  - MedicalResearch was engaged for an evidence-based synthesis of outcomes, progression patterns, CNS activity, and resistance mechanisms specific to KRAS G12C\u2013mutated NSCLC after chemo-IO\u2014precisely its specialty.\n  - Radiology was identified as optional and appropriately not invoked because no new imaging files were provided; the orchestrator relied on radiology reports from PatientHistory instead.\n\n- Avoidance of unnecessary agents:\n  - The orchestrator did not over-call agents. Radiology was not used without imaging files, and for the final prognosis question it reused existing outputs rather than re-invoking agents unnecessarily.\n\n- Effective routing of complex questions:\n  - Prognosis and progression-pattern questions were routed to MedicalResearch with well-structured, case-specific inputs, ensuring trial-based, citation-supported outputs.\n  - Clarifications affecting staging and CNS risk were routed back to PatientHistory, which is the right source-of-truth for chart details.\n\n- Appropriate multi-agent orchestration:\n  - The orchestrator leveraged multiple agents in a logical sequence (PatientHistory \u2192 PatientStatus \u2192 PatientHistory for gaps \u2192 MedicalResearch \u2192 synthesis). Each handoff was purposeful and minimized redundancy.\n\n- Additional strengths:\n  - Clear process control and explicit reminders for handoff back to the orchestrator.\n  - Sensible decision to synthesize the final prognosis directly from prior agent outputs without redundant agent calls.\n  - Sensitivity to optional imaging review and user preference before invoking Radiology.\n\nOverall, the orchestrator matched tasks to the optimal agents, avoided unnecessary engagements, and coordinated inputs to produce a coherent, evidence-based prognosis and progression overview."
          }
        },
        {
          "id": "2bfa9006d7dce51e823d4dd688ce1e076bfa5413f4b13729b370a8a77c885502",
          "patient_id": null,
          "result": {
            "score": 3,
            "explanation": "Rating: 3\n\nExplanation:\n- Appropriate agent selection plan: The orchestrator correctly identified PatientHistory as the primary agent to retrieve longitudinal data (stage, biomarkers, treatments/responses, imaging reports) and set Radiology as a conditional agent only if imaging files were available. This mapping aligns well with the user\u2019s request for a comprehensive timeline based on the full clinical picture, including recent imaging.\n- Avoided unnecessary agents: The orchestrator did not introduce extraneous agents beyond PatientHistory and Radiology, which is appropriate for the task.\n- Missed opportunities in routing/execution: Despite a sound plan, the orchestrator repeatedly asked for confirmations (date range, imaging files) and never actually invoked PatientHistory after defaulting to the entire course of care. Once the user indicated no date range, the orchestrator could have proceeded to retrieve records and later incorporated any imaging files if provided. This failure to move from planning to execution meant specialized agents were not leveraged when they should have been.\n- Use of multiple agents: The conditional use of Radiology was sensible, but no agents were ultimately used, and the orchestrator did not escalate or proceed based on available information.\n\nOverall, the selection logic was generally appropriate, but the lack of actual routing and the repetitive confirmation loop lowered effectiveness."
          }
        },
        {
          "id": "ffd22edf77983e200a71c609b82a587776a0296a33cead4062b8792d3da3145e",
          "patient_id": null,
          "result": {
            "score": 5,
            "explanation": "Rating: 5\n\nExplanation:\n- The Orchestrator consistently selected the right specialized agents at each step:\n  - Started with ClinicalTrials to define the exact data elements and accepted formats needed for eligibility matching, which is the correct authority for trial criteria.\n  - Then engaged PatientStatus to align on a compatible patient status artifact and confirm minimal mandatory fields, ensuring interoperability with ClinicalTrials\u2019 schema.\n  - Planned to use PatientHistory to retrieve the actual patient data from the chart once the user provides the patient ID\u2014an appropriate data source for clinical details.\n  - Intended to route back to PatientStatus to construct a clean, standardized artifact, and finally to ClinicalTrials to generate eligible trials. This sequencing is sound.\n- The Orchestrator avoided unnecessary agents. It only involved ClinicalTrials, PatientStatus, and (planned) PatientHistory, all of which are directly relevant to the task.\n- It handled the complex, multi-stage question effectively, leveraging multiple agents where appropriate to gather requirements, standardize data, and perform matching.\n- It also accounted for geographic filtering and logistics preferences, correctly routing that consideration to the ClinicalTrials agent\u2019s capabilities.\n- The Orchestrator respected data dependencies (waiting for patient ID before calling PatientHistory) and maintained control flow by asking agents to return \u201cback to you: Orchestrator.\u201d\n- Any minor repetition of the plan did not detract from appropriate agent selection and routing.\n\nOverall, this is an excellent orchestration of specialized agents for a complex clinical trial matching task."
          }
        }
      ]
    },
    "task_completion_and_focus": {
      "average_score": 3.0,
      "num_evaluations": 3,
      "num_errors": 0,
      "results": [
        {
          "id": "21f2e08161ef6e94c4b7835c02b8060bf534659c2109be987f2c113a3f397c11",
          "patient_id": "patient_4",
          "result": {
            "score": 5,
            "explanation": "Rating: 5\n\nThe system fully completed the user\u2019s primary request and maintained focus throughout. Specifically:\n- It delivered a short, well-structured report that included all requested components: a clinical snapshot, an estimated prognosis with quantitative ranges, and plausible progression pathways. This directly addressed the original prompt to base the report on stage, biomarkers, treatment response, and recent imaging.\n- It handled multi-part requirements by clearly outlining prognosis (with evidence-based ORR, PFS, OS ranges) and progression pathways (thoracic, extrathoracic, CNS, and resistance-related patterns), while also citing the factors from the patient\u2019s profile that influenced the estimates.\n- Side tasks (clarifying M1a basis, confirming CNS imaging status, updating ECOG, and deciding whether to involve Radiology) were managed efficiently. Each was executed only insofar as needed to refine the main task, and the orchestrator consistently returned control to the main objective.\n- The system remained focused on the original goal despite ancillary steps. After PatientHistory and PatientStatus filled data gaps and MedicalResearch provided context, the orchestrator promptly produced the report. It avoided unnecessary detours (e.g., did not invoke Radiology when not required).\n- When the user followed up with a narrower question about prognosis, the orchestrator responded succinctly using the previously gathered inputs, maintaining coherence and not rehashing irrelevant details.\n\nOverall, the orchestration was tight, the deliverable matched the user\u2019s request, side tasks were appropriately contained, and the conversation consistently returned to and fulfilled the main objective."
          }
        },
        {
          "id": "2bfa9006d7dce51e823d4dd688ce1e076bfa5413f4b13729b370a8a77c885502",
          "patient_id": null,
          "result": {
            "score": 1,
            "explanation": "Rating: 1\n\nThe assistant failed to complete the primary task of generating a comprehensive patient timeline. It remained stuck in a loop of preflight clarifications and repeated the same questions multiple times without progressing. Although it successfully confirmed the patient ID (\u201cpatient_4\u201d), it did not proceed to instruct PatientHistory to retrieve records or synthesize any timeline content. When the user indicated \u201cno date range specified\u2014I'll default to covering the entire course of care,\u201d the assistant did not adopt that decision and move forward; instead, it continued to re-ask about date range and imaging files, causing further delays. It also repeatedly restated its plan and agent handoff protocol rather than executing it. There was no evidence of handling side tasks efficiently or returning to the main objective. Ultimately, no timeline was produced, and the assistant lost focus by cycling through the same setup prompts instead of advancing the workflow."
          }
        },
        {
          "id": "ffd22edf77983e200a71c609b82a587776a0296a33cead4062b8792d3da3145e",
          "patient_id": null,
          "result": {
            "score": 3,
            "explanation": "Rating: 3\n\nExplanation:\n- The primary objective was to retrieve the list of clinical trials the patient is eligible for. This was not achieved because the system did not receive a patient ID or necessary patient details from the user; thus, it could not proceed to pull PatientHistory or run the matching. \n- The system effectively handled the emergent side tasks:\n  - ClinicalTrials provided a thorough, precise schema with mandatory vs optional fields, accepted value sets, tolerances, geography filtering capabilities, and a compact JSON template.\n  - PatientStatus provided its minimal mandatory fields, a compatible JSON template, accepted value sets, recency requirements, conflict resolution logic, and coding flexibility preferences.\n  - Both agents followed instructions to return control (\u201cback to you: Orchestrator\u201d), and the Orchestrator maintained the workflow structure.\n- Focus maintenance was strong. After handling each side task, the Orchestrator explicitly returned to the main plan, restated steps needed to reach the final goal, and repeatedly requested the necessary inputs (patient ID, location, travel radius, logistics) to proceed to PatientHistory and then ClinicalTrials.\n- However, because no trial list was produced, the primary task remained incomplete. Also, there was minor potential friction not reconciled (PatientStatus adding sex_at_birth as a required field beyond ClinicalTrials\u2019 minimum), but it did not derail the process.\n- Overall, the system maintained focus and progressed preparatory steps well but did not complete the main task due to missing user-provided data, yielding an average score."
          }
        }
      ]
    },
    "information_integration": {
      "average_score": 5.0,
      "num_evaluations": 1,
      "num_errors": 2,
      "results": [
        {
          "id": "21f2e08161ef6e94c4b7835c02b8060bf534659c2109be987f2c113a3f397c11",
          "patient_id": "patient_4",
          "result": {
            "score": 5,
            "explanation": "Rating: 5\n\nThe orchestrator demonstrated excellent integration of information from multiple specialized agents into coherent, patient-tailored outputs.\n\n- Effective combination of sources: It pulled patient-specific details from PatientHistory (basis for M1a via contralateral nodules, absence of CNS imaging through the date, latest ECOG), synthesized the clinical snapshot from PatientStatus (stage, treatment course, biomarkers, comorbidities), and merged these with MedicalResearch\u2019s evidence (trial-level PFS/OS, ORR ranges, M1a prognostic context, co-mutation impacts, CNS activity, and resistance patterns). The final report and subsequent concise prognosis answer clearly reflect this multi-source integration.\n\n- Handling of uncertainty/possible contradictions: The orchestrator appropriately reconciled the oncology note that \u201ca brain MRI was reviewed\u201d with the lack of a dedicated CNS imaging report by stating there was no CNS imaging on record through the date and flagging CNS status as an uncertainty affecting prognosis. It also explicitly noted unknown co-mutations and framed their potential impact as modifiers rather than certainties.\n\n- Coherent, comprehensive synthesis: The short report included a clinical snapshot, quantitative prognosis estimates, progression pathways (thoracic vs extrathoracic vs CNS), resistance mechanisms, and key uncertainties/watchpoints, all tied back to the patient\u2019s profile and supported by representative trials (KRYSTAL-1, CodeBreaK 100/200) and IASLC staging analyses. This goes beyond repeating agent outputs, creating a cohesive narrative.\n\n- Identifying cross-agent connections: It connected M1a status from PatientHistory to the favorable prognostic context from MedicalResearch, linked PD-L1 negativity to its limited relevance for G12C inhibitor efficacy, and tied resistance mechanisms to likely clinical progression patterns. The final prognosis answer reused and distilled these integrated insights efficiently without unnecessary additional agent calls.\n\nOverall, the orchestrator\u2019s integration was seamless, accurate, and context-aware, achieving insights beyond any single agent\u2019s contribution."
          }
        },
        {
          "id": "2bfa9006d7dce51e823d4dd688ce1e076bfa5413f4b13729b370a8a77c885502",
          "patient_id": null,
          "result": {
            "error": "(\"<class 'semantic_kernel.connectors.ai.open_ai.services.azure_chat_completion.AzureChatCompletion'> service failed to complete the prompt\", APITimeoutError('Request timed out.'))",
            "trace": "Traceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 101, in map_httpcore_exceptions\n    yield\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 394, in handle_async_request\n    resp = await self._pool.handle_async_request(req)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection_pool.py\", line 256, in handle_async_request\n    raise exc from None\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection_pool.py\", line 236, in handle_async_request\n    response = await connection.handle_async_request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 101, in handle_async_request\n    raise exc\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 78, in handle_async_request\n    stream = await self._connect(request)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 124, in _connect\n    stream = await self._network_backend.connect_tcp(**kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_backends\\auto.py\", line 31, in connect_tcp\n    return await self._backend.connect_tcp(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_backends\\anyio.py\", line 113, in connect_tcp\n    with map_exceptions(exc_map):\n         ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\lukasmatzi\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py\", line 158, in __exit__\n    self.gen.throw(value)\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_exceptions.py\", line 14, in map_exceptions\n    raise to_exc(exc) from exc\nhttpcore.ConnectTimeout\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1529, in request\n    response = await self._client.send(\n               ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1629, in send\n    response = await self._send_handling_auth(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1657, in _send_handling_auth\n    response = await self._send_handling_redirects(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1694, in _send_handling_redirects\n    response = await self._send_single_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1730, in _send_single_request\n    response = await transport.handle_async_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 393, in handle_async_request\n    with map_httpcore_exceptions():\n         ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\lukasmatzi\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py\", line 158, in __exit__\n    self.gen.throw(value)\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 118, in map_httpcore_exceptions\n    raise mapped_exc(message) from exc\nhttpx.ConnectTimeout\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 87, in _send_completion_request\n    response = await self.client.chat.completions.create(**settings_dict)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\resources\\chat\\completions\\completions.py\", line 2583, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1794, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1547, in request\n    raise APITimeoutError(request=request) from err\nopenai.APITimeoutError: Request timed out.\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\evaluator.py\", line 215, in _evaluate\n    evaluation_results = await metric.evaluate(\n                         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\metrics\\base.py\", line 411, in evaluate\n    return await self._evaluate_content(chat_history)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\metrics\\base.py\", line 431, in _evaluate_content\n    response = await self.evaluation_llm_service.get_chat_message_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\chat_completion_client_base.py\", line 190, in get_chat_message_content\n    results = await self.get_chat_message_contents(chat_history=chat_history, settings=settings, **kwargs)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\chat_completion_client_base.py\", line 134, in get_chat_message_contents\n    return await self._inner_get_chat_message_contents(chat_history, settings)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\utils\\telemetry\\model_diagnostics\\decorators.py\", line 112, in wrapper_decorator\n    return await completion_func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_chat_completion_base.py\", line 88, in _inner_get_chat_message_contents\n    response = await self._send_request(settings)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 59, in _send_request\n    return await self._send_completion_request(settings)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 104, in _send_completion_request\n    raise ServiceResponseException(\nsemantic_kernel.exceptions.service_exceptions.ServiceResponseException: (\"<class 'semantic_kernel.connectors.ai.open_ai.services.azure_chat_completion.AzureChatCompletion'> service failed to complete the prompt\", APITimeoutError('Request timed out.'))\n"
          }
        },
        {
          "id": "ffd22edf77983e200a71c609b82a587776a0296a33cead4062b8792d3da3145e",
          "patient_id": null,
          "result": {
            "error": "(\"<class 'semantic_kernel.connectors.ai.open_ai.services.azure_chat_completion.AzureChatCompletion'> service failed to complete the prompt\", APIConnectionError('Connection error.'))",
            "trace": "Traceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 101, in map_httpcore_exceptions\n    yield\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 394, in handle_async_request\n    resp = await self._pool.handle_async_request(req)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection_pool.py\", line 256, in handle_async_request\n    raise exc from None\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection_pool.py\", line 236, in handle_async_request\n    response = await connection.handle_async_request(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 101, in handle_async_request\n    raise exc\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 78, in handle_async_request\n    stream = await self._connect(request)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_async\\connection.py\", line 124, in _connect\n    stream = await self._network_backend.connect_tcp(**kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_backends\\auto.py\", line 31, in connect_tcp\n    return await self._backend.connect_tcp(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_backends\\anyio.py\", line 113, in connect_tcp\n    with map_exceptions(exc_map):\n         ^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\lukasmatzi\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py\", line 158, in __exit__\n    self.gen.throw(value)\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpcore\\_exceptions.py\", line 14, in map_exceptions\n    raise to_exc(exc) from exc\nhttpcore.ConnectError: [Errno 11001] getaddrinfo failed\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1529, in request\n    response = await self._client.send(\n               ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1629, in send\n    response = await self._send_handling_auth(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1657, in _send_handling_auth\n    response = await self._send_handling_redirects(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1694, in _send_handling_redirects\n    response = await self._send_single_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_client.py\", line 1730, in _send_single_request\n    response = await transport.handle_async_request(request)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 393, in handle_async_request\n    with map_httpcore_exceptions():\n         ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"C:\\Users\\lukasmatzi\\AppData\\Local\\Programs\\Python\\Python312\\Lib\\contextlib.py\", line 158, in __exit__\n    self.gen.throw(value)\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\httpx\\_transports\\default.py\", line 118, in map_httpcore_exceptions\n    raise mapped_exc(message) from exc\nhttpx.ConnectError: [Errno 11001] getaddrinfo failed\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 87, in _send_completion_request\n    response = await self.client.chat.completions.create(**settings_dict)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\resources\\chat\\completions\\completions.py\", line 2583, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1794, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\openai\\_base_client.py\", line 1561, in request\n    raise APIConnectionError(request=request) from err\nopenai.APIConnectionError: Connection error.\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\evaluator.py\", line 215, in _evaluate\n    evaluation_results = await metric.evaluate(\n                         ^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\metrics\\base.py\", line 411, in evaluate\n    return await self._evaluate_content(chat_history)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\notebooks\\evaluations\\../../src\\evaluation\\metrics\\base.py\", line 431, in _evaluate_content\n    response = await self.evaluation_llm_service.get_chat_message_content(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\chat_completion_client_base.py\", line 190, in get_chat_message_content\n    results = await self.get_chat_message_contents(chat_history=chat_history, settings=settings, **kwargs)\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\chat_completion_client_base.py\", line 134, in get_chat_message_contents\n    return await self._inner_get_chat_message_contents(chat_history, settings)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\utils\\telemetry\\model_diagnostics\\decorators.py\", line 112, in wrapper_decorator\n    return await completion_func(*args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_chat_completion_base.py\", line 88, in _inner_get_chat_message_contents\n    response = await self._send_request(settings)\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 59, in _send_request\n    return await self._send_completion_request(settings)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"c:\\Users\\lukasmatzi\\Documents\\projects\\repos\\healthcare-agent-orchestrator\\.venv\\Lib\\site-packages\\semantic_kernel\\connectors\\ai\\open_ai\\services\\open_ai_handler.py\", line 104, in _send_completion_request\n    raise ServiceResponseException(\nsemantic_kernel.exceptions.service_exceptions.ServiceResponseException: (\"<class 'semantic_kernel.connectors.ai.open_ai.services.azure_chat_completion.AzureChatCompletion'> service failed to complete the prompt\", APIConnectionError('Connection error.'))\n"
          }
        }
      ]
    }
  }
}